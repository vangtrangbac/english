<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Manager</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://code.responsivevoice.org/responsivevoice.js?key=free"></script>
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #e4e4e7;
            --text-secondary: #a1a1aa;
            --accent: #00d9ff;
            --accent-hover: #00b8d4;
            --accent-success: #4ade80;
            --accent-danger: #ff6b6b;
            --accent-warning: #fbbf24;
            --border: #27272a;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .container { display: flex; min-height: 100vh; }
        
        /* Mobile toggle */
        .mobile-category-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 217, 255, 0.4);
        }
        
        /* Sidebar */
        .sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .sidebar-header h1 {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        
        .add-form {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .add-form input, .add-form select {
            flex: 1;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        .add-form button {
            padding: 0.5rem 0.8rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .category-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        /* Parent Category */
        .parent-category {
            margin-bottom: 0.5rem;
        }
        
        .parent-header {
            display: flex;
            align-items: center;
            padding: 0.6rem 0.8rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .parent-header:hover {
            background: var(--bg-primary);
        }
        
        .parent-expand {
            margin-right: 0.5rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
            font-size: 0.8rem;
        }
        
        .parent-category.expanded .parent-expand {
            transform: rotate(90deg);
        }
        
        .parent-name {
            flex: 1;
            font-weight: 600;
            color: var(--accent);
        }
        
        .parent-count {
            background: var(--bg-secondary);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .parent-actions {
            display: flex;
            gap: 0.2rem;
            margin-left: 0.5rem;
        }
        
        .parent-actions button {
            padding: 0.2rem 0.4rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.75rem;
        }
        
        .parent-actions button:hover {
            background: rgba(255,255,255,0.1);
        }
        
        /* Child Categories */
        .children-list {
            display: none;
            padding-left: 1rem;
            margin-top: 0.3rem;
        }
        
        .parent-category.expanded .children-list {
            display: block;
        }
        
        .child-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.8rem;
            margin: 0.2rem 0;
            background: var(--bg-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        
        .child-item:hover {
            background: var(--bg-primary);
        }
        
        .child-item.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-left-color: var(--accent-success);
        }
        
        .child-name {
            flex: 1;
            font-size: 0.9rem;
        }
        
        .child-count {
            background: var(--bg-tertiary);
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            font-size: 0.7rem;
            margin-left: 0.3rem;
        }
        
        .child-item.active .child-count {
            background: var(--bg-primary);
            color: var(--accent);
        }
        
        .child-actions {
            display: flex;
            gap: 0.2rem;
            margin-left: 0.3rem;
        }
        
        .child-actions button {
            padding: 0.2rem 0.3rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.7rem;
        }
        
        .child-item.active .child-actions button {
            color: var(--bg-primary);
        }
        
        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .main-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }
        
        .main-header h2 {
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        .breadcrumb {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        
        .breadcrumb span {
            color: var(--accent);
        }
        
        .voice-input-section {
            display: flex;
            margin-bottom: 0.5rem;
        }
        
        .voice-input-section input {
            flex: 1;
            padding: 0.8rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .action-buttons button {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        
        .btn-mode {
            background: var(--accent);
            color: var(--bg-primary);
        }
        
        .btn-mode.vi-mode {
            background: var(--accent-success);
        }
        
        .btn-voice {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }
        
        .btn-voice.recording {
            background: var(--accent-danger);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .btn-add {
            background: var(--accent-success);
            color: var(--bg-primary);
        }
        
        /* Auto reader */
        .auto-reader {
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: none;
        }
        
        .auto-reader.show { display: block; }
        
        .reader-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .reader-header h3 {
            color: var(--accent);
            font-size: 1rem;
        }
        
        .reader-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .reader-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
        }
        
        .reader-btn.play { background: var(--accent-success); color: var(--bg-primary); }
        .reader-btn.pause { background: var(--accent-warning); color: var(--bg-primary); }
        .reader-btn.stop { background: var(--accent-danger); color: white; }
        
        .reader-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 0.8rem;
        }
        
        .reader-options label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .reader-options select {
            padding: 0.3rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
        }
        
        .reader-options .checkbox-label {
            cursor: pointer;
            user-select: none;
        }
        
        .reader-options .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }
        
        .reader-progress {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-primary));
            padding: 0.8rem 1rem;
            border-radius: 10px;
            border: 1px solid var(--accent);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.2);
        }
        
        .reader-status { 
            font-size: 0.9rem; 
            color: var(--accent);
            font-weight: 600;
            background: var(--bg-tertiary);
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            white-space: nowrap;
        }
        
        .reader-current-word { 
            color: var(--text-primary); 
            font-size: 1.1rem;
            flex: 1;
        }
        
        .reader-current-word strong {
            color: var(--accent);
            font-size: 1.3rem;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }
        
        /* Practice mode - hide Vietnamese */
        .practice-mode .vocab-meaning-vi {
            filter: blur(8px);
            cursor: pointer;
            transition: filter 0.2s;
        }
        
        .practice-mode .vocab-meaning-vi:hover {
            filter: blur(0);
        }
        
        .practice-mode .vocab-details p:first-child {
            filter: blur(8px);
            cursor: pointer;
            transition: filter 0.2s;
        }
        
        .practice-mode .vocab-details p:first-child:hover {
            filter: blur(0);
        }
        
        /* Toggle switch */
        .toggle-practice {
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        
        .toggle-practice:hover {
            background: var(--bg-secondary) !important;
        }
        
        .toggle-practice.active {
            background: var(--accent) !important;
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        
        /* Vocabulary list */
        .vocab-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }
        
        .vocab-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .vocab-item {
            background: var(--bg-secondary);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s;
        }
        
        .vocab-item.learned { opacity: 0.5; }
        
        .vocab-item.reading {
            border: 2px solid var(--accent);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.3);
        }
        
        .vocab-header {
            display: flex;
            align-items: center;
            padding: 0.8rem 1rem;
            cursor: pointer;
            gap: 0.8rem;
        }
        
        .vocab-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-success);
            cursor: pointer;
        }
        
        .vocab-number {
            color: var(--text-secondary);
            font-size: 0.85rem;
            min-width: 30px;
        }
        
        .vocab-word {
            font-weight: 600;
            color: var(--accent);
            font-size: 1.1rem;
        }
        
        .vocab-phonetic {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .vocab-pos {
            background: var(--accent);
            color: var(--bg-primary);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .vocab-meaning-vi {
            color: var(--accent-success);
            font-size: 0.95rem;
            margin-left: auto;
            margin-right: 1rem;
        }
        
        .vocab-audio-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--accent);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .vocab-expand {
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .vocab-item.expanded .vocab-expand {
            transform: rotate(180deg);
        }
        
        .vocab-details {
            display: none;
            padding: 0 1rem 1rem;
            border-top: 1px solid var(--border);
        }
        
        .vocab-item.expanded .vocab-details {
            display: block;
        }
        
        .vocab-definition {
            color: var(--text-secondary);
            margin: 0.8rem 0;
            font-size: 0.95rem;
        }
        
        .vocab-definition-vi, .definition-vi {
            color: var(--accent-success);
            font-size: 0.9rem;
            margin: 0.3rem 0 0.8rem 0;
        }
        
        .vocab-example {
            background: var(--bg-tertiary);
            padding: 0.8rem;
            border-radius: 6px;
            font-style: italic;
            color: var(--text-secondary);
            border-left: 3px solid var(--accent);
        }
        
        .vocab-example-vi {
            padding: 0.5rem 0.8rem;
            color: var(--accent-success);
            font-size: 0.9rem;
            font-style: normal;
        }
        
        .vocab-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .vocab-actions button {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        
        .vocab-actions button.edit { background: var(--accent); color: var(--bg-primary); }
        .vocab-actions button.delete { background: var(--accent-danger); color: white; }
        .vocab-actions button.sync {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        
        .vocab-actions button.sync.spinning i {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .pagination button {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
        }
        
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination span { color: var(--text-secondary); }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        .modal.show { display: flex; }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .modal-header h3 { color: var(--accent); }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .modal-body { padding: 1.5rem; }
        
        .form-group { margin-bottom: 1rem; }
        
        .form-group label {
            display: block;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.8rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .modal-footer button {
            padding: 0.7rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .btn-cancel { background: var(--bg-tertiary); color: var(--text-primary); }
        .btn-save { background: var(--accent-success); color: var(--bg-primary); }
        
        /* Review Modal */
        .review-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .review-item {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border);
        }
        
        .review-item-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
        }
        
        .review-item-header input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-success);
        }
        
        .review-word { color: var(--accent); font-weight: 600; font-size: 1.1rem; }
        
        .review-pos {
            background: var(--accent);
            color: var(--bg-primary);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }
        
        .review-phonetic { color: var(--text-secondary); font-size: 0.9rem; }
        
        .review-info { font-size: 0.9rem; color: var(--text-secondary); }
        .review-info p { margin: 0.3rem 0; }
        .review-info strong { color: var(--text-primary); }
        
        .review-example {
            background: var(--bg-secondary);
            padding: 0.6rem;
            border-radius: 4px;
            font-style: italic;
            margin-top: 0.5rem;
            border-left: 3px solid var(--accent);
        }
        
        .review-example-vi {
            padding: 0.3rem 0.6rem;
            color: var(--accent-success);
            font-size: 0.85rem;
            font-style: normal;
        }
        
        .review-loading {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
        }
        
        .review-loading i {
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 1rem;
            animation: spin 1s linear infinite;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 2000;
            transform: translateX(150%);
            transition: transform 0.3s;
        }
        
        .toast.show { transform: translateX(0); }
        .toast.success { background: var(--accent-success); }
        .toast.error { background: var(--accent-danger); }
        .toast.info { background: var(--accent); color: var(--bg-primary); }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { width: 260px; }
        }
        
        @media (max-width: 600px) {
            .mobile-category-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                bottom: 0;
                width: 85%;
                max-width: 300px;
                z-index: 1001;
                transition: left 0.3s;
            }
            
            .sidebar.show { left: 0; }
            
            .sidebar-overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
            }
            
            .sidebar-overlay.show { display: block; }
            
            .main-header { padding: 1rem; }
            
            .action-buttons { 
                flex-wrap: wrap;
            }
            .action-buttons button { 
                flex: 1;
                justify-content: center;
                min-width: 80px;
                padding: 0.5rem 0.6rem;
                font-size: 0.8rem;
            }
            
            .vocab-header { 
                padding: 0.6rem; 
                gap: 0.4rem;
                flex-wrap: wrap;
            }
            .vocab-word { font-size: 0.95rem; }
            .vocab-phonetic { font-size: 0.8rem; }
            .vocab-meaning-vi { 
                font-size: 0.85rem;
                margin-left: 0;
                margin-right: 0.5rem;
            }
            .vocab-number { min-width: 24px; font-size: 0.8rem; }
            .vocab-pos { font-size: 0.7rem; padding: 0.1rem 0.4rem; }
            .vocab-container { padding: 0.5rem; }
            .reader-options { gap: 0.5rem; }
            .reader-options label { font-size: 0.8rem; }
            .reader-options select { font-size: 0.8rem; padding: 0.2rem 0.3rem; }
            .auto-reader { padding: 0.8rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar-overlay" onclick="closeMobileSidebar()"></div>
        
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-book"></i> Vocabulary</h1>
                
                <!-- Add Parent Category -->
                <div class="add-form">
                    <input type="text" id="newParentName" placeholder="Tên nhóm mới...">
                    <button onclick="addParentCategory()" title="Thêm nhóm"><i class="fas fa-folder-plus"></i></button>
                </div>
                
                <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <i class="fas fa-info-circle"></i> Nhấn <i class="fas fa-plus"></i> trên nhóm để thêm category
                </p>
            </div>
            <div class="category-list" id="categoryList"></div>
        </aside>
        
        <main class="main-content">
            <header class="main-header">
                <div class="breadcrumb" id="breadcrumb"></div>
                <h2 id="currentCategoryTitle">Chọn category</h2>
                <div class="voice-input-section">
                    <input type="text" id="wordInput" placeholder="Nhập từ tiếng Anh...">
                </div>
                <div class="action-buttons">
                    <button class="btn-mode" id="searchModeBtn" onclick="toggleSearchMode()">
                        <i class="fas fa-exchange-alt"></i> EN→VI
                    </button>
                    <button class="btn-voice" id="voiceBtn" onclick="toggleVoiceInput()">
                        <i class="fas fa-microphone"></i> Voice
                    </button>
                    <button class="btn-add" onclick="fetchAndReview()">
                        <i class="fas fa-search"></i> Tìm
                    </button>
                    <button class="toggle-practice" id="practiceToggle" onclick="togglePracticeMode()">
                        <i class="fas fa-eye-slash"></i> Ẩn nghĩa
                    </button>
                </div>
            </header>
            
            <section class="auto-reader" id="autoReader">
                <div class="reader-header">
                    <h3><i class="fas fa-headphones"></i> Auto Read</h3>
                    <div class="reader-controls">
                        <button class="reader-btn play" onclick="startAutoRead()"><i class="fas fa-play"></i> Play</button>
                        <button class="reader-btn pause" onclick="pauseAutoRead()" style="display:none;"><i class="fas fa-pause"></i> Pause</button>
                        <button class="reader-btn stop" onclick="stopAutoRead()"><i class="fas fa-stop"></i> Stop</button>
                    </div>
                </div>
                <div class="reader-options">
                    <label>
                        Chế độ:
                        <select id="readerMode">
                            <option value="current">Category hiện tại</option>
                            <option value="unlearned">Chỉ chưa học</option>
                            <option value="all">Tất cả</option>
                        </select>
                    </label>
                    <label>
                        Delay:
                        <select id="readerDelay">
                            <option value="1000">1s</option>
                            <option value="2000" selected>2s</option>
                            <option value="3000">3s</option>
                            <option value="5000">5s</option>
                            <option value="10000">10s</option>
                        </select>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="readExample" onchange="saveReaderSettings()">
                        <span>Đọc example</span>
                    </label>
                </div>
                <div class="reader-progress">
                    <span class="reader-status" id="readerStatus">Sẵn sàng</span>
                    <span class="reader-current-word" id="readerCurrentWord"></span>
                </div>
            </section>
            
            <div class="vocab-container">
                <div class="vocab-list" id="vocabList">
                    <div class="empty-state">
                        <i class="fas fa-folder-open"></i>
                        <p>Chọn một category để xem từ vựng</p>
                    </div>
                </div>
            </div>
            
            <div class="pagination" id="pagination" style="display:none;"></div>
        </main>
    </div>
    
    <button class="mobile-category-toggle" onclick="toggleMobileSidebar()">
        <i class="fas fa-list"></i>
    </button>
    
    <!-- Edit Modal -->
    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Chỉnh sửa từ vựng</h3>
                <button class="modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editVocabId">
                <div class="form-group">
                    <label>Từ vựng</label>
                    <input type="text" id="editWord">
                </div>
                <div class="form-group">
                    <label>Phiên âm</label>
                    <input type="text" id="editPhonetic">
                </div>
                <div class="form-group">
                    <label>Loại từ</label>
                    <select id="editPos">
                        <option value="n">Noun (n)</option>
                        <option value="v">Verb (v)</option>
                        <option value="adj">Adjective (adj)</option>
                        <option value="adv">Adverb (adv)</option>
                        <option value="prep">Preposition (prep)</option>
                        <option value="conj">Conjunction (conj)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Nghĩa tiếng Việt</label>
                    <input type="text" id="editMeaningVi">
                </div>
                <div class="form-group">
                    <label>Định nghĩa</label>
                    <textarea id="editDefinition"></textarea>
                </div>
                <div class="form-group">
                    <label>Dịch định nghĩa (VN)</label>
                    <textarea id="editDefinitionVi"></textarea>
                </div>
                <div class="form-group">
                    <label>Ví dụ</label>
                    <textarea id="editExample"></textarea>
                </div>
                <div class="form-group">
                    <label>Dịch ví dụ (VN)</label>
                    <textarea id="editExampleVi"></textarea>
                </div>
                <div class="form-group">
                    <label>Audio URL</label>
                    <input type="text" id="editAudio">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeEditModal()">Hủy</button>
                <button class="btn-save" onclick="saveEditVocab()">Lưu</button>
            </div>
        </div>
    </div>
    
    <!-- Review Modal -->
    <div class="modal" id="reviewModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3><i class="fas fa-eye"></i> Review trước khi thêm</h3>
                <button class="modal-close" onclick="closeReviewModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="reviewContent">
                    <div class="review-loading">
                        <i class="fas fa-spinner"></i>
                        <p>Đang tìm kiếm thông tin...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeReviewModal()">Hủy</button>
                <button class="btn-save" onclick="confirmAddSelected()">
                    <i class="fas fa-plus"></i> Thêm đã chọn
                </button>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <script>
        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyDpwi1P4QuwmBi6ytnH13LZfNY4ECQI0nQ",
            authDomain: "vocabulary-manager-cd26d.firebaseapp.com",
            databaseURL: "https://vocabulary-manager-cd26d-default-rtdb.firebaseio.com",
            projectId: "vocabulary-manager-cd26d",
            storageBucket: "vocabulary-manager-cd26d.firebasestorage.app",
            messagingSenderId: "888267782177",
            appId: "1:888267782177:web:257d782a51575d80064b60"
        };

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // State - 2 level categories
        let parentCategories = {};
        let currentParentId = null;
        let currentChildId = null;
        let currentPage = 1;
        const ITEMS_PER_PAGE = 25;
        
        // Auto read state
        let isReading = false;
        let isPaused = false;
        let readingList = [];
        let readingIndex = 0;
        let readingTimeout = null;
        
        // Speech recognition
        let recognition = null;
        let isRecording = false;
        
        // Review data
        let reviewData = [];
        
        // Search mode: 'en' (English to Vietnamese) or 'vi' (Vietnamese to English)
        let searchMode = 'en';
        
        // Init
        document.addEventListener('DOMContentLoaded', () => {
            initFirebaseListeners();
            initSpeechRecognition();
            initPracticeMode();
            loadReaderSettings();
        });
        
        function initFirebaseListeners() {
            database.ref('parentCategories').on('value', async (snapshot) => {
                const data = snapshot.val();
                
                // Check if we need to migrate old data
                if (!data) {
                    await migrateOldData();
                    return;
                }
                
                parentCategories = data;
                renderCategories();
                
                if (currentParentId && currentChildId) {
                    const parent = parentCategories[currentParentId];
                    if (parent && parent.children && parent.children[currentChildId]) {
                        renderVocabularies();
                    }
                }
            }, (error) => {
                console.error('Firebase error:', error);
                showToast('Lỗi kết nối Firebase', 'error');
            });
        }
        
        // Migrate old single-level categories to new 2-level structure
        async function migrateOldData() {
            showToast('Đang migrate dữ liệu...', 'info');
            
            const oldSnapshot = await database.ref('categories').once('value');
            const oldCategories = oldSnapshot.val();
            
            if (!oldCategories) {
                // No old data, create default parent
                await database.ref('parentCategories').push({
                    name: 'Default',
                    children: {}
                });
                showToast('Đã tạo nhóm Default', 'success');
                return;
            }
            
            // Create Default parent with all old categories as children
            const defaultParent = {
                name: 'Default',
                children: {}
            };
            
            Object.entries(oldCategories).forEach(([id, cat]) => {
                defaultParent.children[id] = {
                    name: cat.name,
                    vocabularies: cat.vocabularies || {}
                };
            });
            
            // Save to new structure
            await database.ref('parentCategories').push(defaultParent);
            
            // Remove old structure (optional - keep for safety)
            // await database.ref('categories').remove();
            
            showToast(`Đã migrate ${Object.keys(oldCategories).length} categories vào Default!`, 'success');
        }
        
        // Render 2-level categories
        function renderCategories() {
            const list = document.getElementById('categoryList');
            list.innerHTML = '';
            
            Object.entries(parentCategories).forEach(([parentId, parent]) => {
                const children = parent.children || {};
                const childCount = Object.keys(children).length;
                const totalVocabs = Object.values(children).reduce((sum, child) => {
                    return sum + (child.vocabularies ? Object.keys(child.vocabularies).length : 0);
                }, 0);
                
                const isExpanded = currentParentId === parentId;
                
                const parentDiv = document.createElement('div');
                parentDiv.className = `parent-category ${isExpanded ? 'expanded' : ''}`;
                parentDiv.innerHTML = `
                    <div class="parent-header" onclick="toggleParent('${parentId}')">
                        <i class="fas fa-chevron-right parent-expand"></i>
                        <span class="parent-name">${parent.name}</span>
                        <span class="parent-count">${childCount} | ${totalVocabs} từ</span>
                        <div class="parent-actions">
                            <button onclick="event.stopPropagation(); addChildToParent('${parentId}')" title="Thêm category" style="color: var(--accent-success);">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button onclick="event.stopPropagation(); editParent('${parentId}')" title="Sửa">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button onclick="event.stopPropagation(); deleteParent('${parentId}')" title="Xóa">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="children-list">
                        ${Object.entries(children).map(([childId, child]) => {
                            const vocabCount = child.vocabularies ? Object.keys(child.vocabularies).length : 0;
                            const isActive = currentParentId === parentId && currentChildId === childId;
                            return `
                                <div class="child-item ${isActive ? 'active' : ''}" onclick="selectChild('${parentId}', '${childId}')">
                                    <span class="child-name">${child.name}</span>
                                    <span class="child-count">${vocabCount}</span>
                                    <div class="child-actions">
                                        <button onclick="event.stopPropagation(); editChild('${parentId}', '${childId}')" title="Sửa">
                                            <i class="fas fa-edit"></i>
                                        </button>
                                        <button onclick="event.stopPropagation(); deleteChild('${parentId}', '${childId}')" title="Xóa">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                list.appendChild(parentDiv);
            });
        }
        
        function toggleParent(parentId) {
            if (currentParentId === parentId) {
                currentParentId = null;
            } else {
                currentParentId = parentId;
            }
            renderCategories();
        }
        
        function selectChild(parentId, childId) {
            currentParentId = parentId;
            currentChildId = childId;
            currentPage = 1;
            
            const parent = parentCategories[parentId];
            const child = parent.children[childId];
            
            document.getElementById('breadcrumb').innerHTML = `<span>${parent.name}</span> / ${child.name}`;
            document.getElementById('currentCategoryTitle').textContent = child.name;
            document.getElementById('autoReader').classList.add('show');
            
            renderCategories();
            renderVocabularies();
            closeMobileSidebar();
        }
        
        // Parent CRUD
        function addParentCategory() {
            const input = document.getElementById('newParentName');
            const name = input.value.trim();
            if (!name) return;
            
            database.ref('parentCategories').push({ name, children: {} })
                .then(() => {
                    input.value = '';
                    showToast('Đã tạo nhóm!', 'success');
                })
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        function editParent(id) {
            const newName = prompt('Nhập tên mới:', parentCategories[id].name);
            if (newName && newName.trim()) {
                database.ref(`parentCategories/${id}/name`).set(newName.trim())
                    .then(() => showToast('Đã cập nhật!', 'success'))
                    .catch(err => showToast('Lỗi: ' + err.message, 'error'));
            }
        }
        
        function deleteParent(id) {
            const parent = parentCategories[id];
            const childCount = Object.keys(parent.children || {}).length;
            const totalVocabs = Object.values(parent.children || {}).reduce((sum, child) => {
                return sum + (child.vocabularies ? Object.keys(child.vocabularies).length : 0);
            }, 0);
            
            const msg = `⚠️ XÁC NHẬN XÓA NHÓM\n\n` +
                `Tên nhóm: "${parent.name}"\n` +
                `Số category: ${childCount}\n` +
                `Tổng số từ vựng: ${totalVocabs}\n\n` +
                `Bạn có chắc chắn muốn xóa?\nHành động này KHÔNG THỂ hoàn tác!`;
            
            if (!confirm(msg)) return;
            
            database.ref(`parentCategories/${id}`).remove()
                .then(() => {
                    if (currentParentId === id) {
                        currentParentId = null;
                        currentChildId = null;
                        document.getElementById('vocabList').innerHTML = '<div class="empty-state"><i class="fas fa-folder-open"></i><p>Chọn một category</p></div>';
                        document.getElementById('autoReader').classList.remove('show');
                        document.getElementById('breadcrumb').innerHTML = '';
                        document.getElementById('currentCategoryTitle').textContent = 'Chọn category';
                    }
                    showToast('Đã xóa!', 'success');
                })
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        // Child CRUD
        function addChildToParent(parentId) {
            const parent = parentCategories[parentId];
            const name = prompt(`Thêm category mới vào nhóm "${parent.name}":\n\nNhập tên category:`);
            
            if (!name || !name.trim()) return;
            
            database.ref(`parentCategories/${parentId}/children`).push({ 
                name: name.trim(), 
                vocabularies: {} 
            })
                .then(() => {
                    showToast('Đã tạo category!', 'success');
                    // Auto expand parent
                    currentParentId = parentId;
                    renderCategories();
                })
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        function editChild(parentId, childId) {
            const child = parentCategories[parentId].children[childId];
            const newName = prompt('Nhập tên mới:', child.name);
            if (newName && newName.trim()) {
                database.ref(`parentCategories/${parentId}/children/${childId}/name`).set(newName.trim())
                    .then(() => showToast('Đã cập nhật!', 'success'))
                    .catch(err => showToast('Lỗi: ' + err.message, 'error'));
            }
        }
        
        function deleteChild(parentId, childId) {
            const parent = parentCategories[parentId];
            const child = parent.children[childId];
            const vocabCount = child.vocabularies ? Object.keys(child.vocabularies).length : 0;
            
            const msg = `⚠️ XÁC NHẬN XÓA CATEGORY\n\n` +
                `Nhóm: "${parent.name}"\n` +
                `Category: "${child.name}"\n` +
                `Số từ vựng: ${vocabCount}\n\n` +
                `Bạn có chắc chắn muốn xóa?\nHành động này KHÔNG THỂ hoàn tác!`;
            
            if (!confirm(msg)) return;
            
            database.ref(`parentCategories/${parentId}/children/${childId}`).remove()
                .then(() => {
                    if (currentParentId === parentId && currentChildId === childId) {
                        currentChildId = null;
                        document.getElementById('vocabList').innerHTML = '<div class="empty-state"><i class="fas fa-folder-open"></i><p>Chọn một category</p></div>';
                        document.getElementById('autoReader').classList.remove('show');
                    }
                    showToast('Đã xóa!', 'success');
                })
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        // Get current vocabularies path
        function getVocabPath() {
            return `parentCategories/${currentParentId}/children/${currentChildId}/vocabularies`;
        }
        
        function getCurrentVocabularies() {
            if (!currentParentId || !currentChildId) return {};
            const parent = parentCategories[currentParentId];
            if (!parent || !parent.children || !parent.children[currentChildId]) return {};
            return parent.children[currentChildId].vocabularies || {};
        }
        
        // Vocabularies
        function renderVocabularies() {
            const vocabs = getCurrentVocabularies();
            const vocabArray = Object.entries(vocabs).map(([id, v]) => ({ id, ...v }));
            
            vocabArray.sort((a, b) => {
                if (a.learned && !b.learned) return 1;
                if (!a.learned && b.learned) return -1;
                return 0;
            });
            
            const totalPages = Math.ceil(vocabArray.length / ITEMS_PER_PAGE);
            const startIdx = (currentPage - 1) * ITEMS_PER_PAGE;
            const pageItems = vocabArray.slice(startIdx, startIdx + ITEMS_PER_PAGE);
            
            const list = document.getElementById('vocabList');
            
            if (vocabArray.length === 0) {
                list.innerHTML = '<div class="empty-state"><i class="fas fa-inbox"></i><p>Chưa có từ vựng nào</p></div>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            list.innerHTML = pageItems.map((v, idx) => `
                <div class="vocab-item ${v.learned ? 'learned' : ''}" id="vocab-${v.id}">
                    <div class="vocab-header" onclick="toggleVocabExpand('${v.id}')">
                        <input type="checkbox" class="vocab-checkbox" 
                            ${v.learned ? 'checked' : ''} 
                            onclick="event.stopPropagation(); toggleLearned('${v.id}', this.checked)">
                        <span class="vocab-number">${startIdx + idx + 1}.</span>
                        <span class="vocab-word">${v.word}</span>
                        <span class="vocab-phonetic">${v.phonetic || ''}</span>
                        <span class="vocab-pos">${v.partOfSpeech || ''}</span>
                        <span class="vocab-meaning-vi">${v.meaningVi || ''}</span>
                        <button class="vocab-audio-btn" onclick="event.stopPropagation(); playWord('${v.word}', '${v.audio || ''}')">
                            <i class="fas fa-volume-up"></i>
                        </button>
                        <i class="fas fa-chevron-down vocab-expand"></i>
                    </div>
                    <div class="vocab-details">
                        <p><strong>Nghĩa:</strong> ${v.meaningVi || '-'}</p>
                        <p class="vocab-definition"><strong>Definition:</strong> ${v.definition || '-'}</p>
                        ${v.definitionVi ? `<p class="vocab-definition-vi">→ ${v.definitionVi}</p>` : ''}
                        ${v.example ? `
                            <div class="vocab-example">"${v.example}"</div>
                            ${v.exampleVi ? `<div class="vocab-example-vi">→ ${v.exampleVi}</div>` : ''}
                        ` : ''}
                        <div class="vocab-actions">
                            <button class="edit" onclick="openEditModal('${v.id}')"><i class="fas fa-edit"></i> Sửa</button>
                            <button class="delete" onclick="deleteVocabulary('${v.id}')"><i class="fas fa-trash"></i> Xóa</button>
                            <button class="sync" onclick="syncVocabAudio('${v.id}', this)"><i class="fas fa-music"></i> Audio</button>
                            <button class="sync" onclick="syncVocabPhonetic('${v.id}', this)"><i class="fas fa-font"></i> Phonetic</button>
                            <button class="sync" onclick="syncVocabExample('${v.id}', this)"><i class="fas fa-quote-right"></i> Example</button>
                        </div>
                    </div>
                </div>
            `).join('');
            
            const pagDiv = document.getElementById('pagination');
            if (totalPages > 1) {
                pagDiv.style.display = 'flex';
                pagDiv.innerHTML = `
                    <button onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <span>Trang ${currentPage} / ${totalPages}</span>
                    <button onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
                        <i class="fas fa-chevron-right"></i>
                    </button>
                `;
            } else {
                pagDiv.style.display = 'none';
            }
        }
        
        function goToPage(page) {
            currentPage = page;
            renderVocabularies();
            document.querySelector('.vocab-container').scrollTop = 0;
        }
        
        function toggleVocabExpand(id) {
            document.getElementById(`vocab-${id}`).classList.toggle('expanded');
        }
        
        function toggleLearned(id, learned) {
            database.ref(`${getVocabPath()}/${id}/learned`).set(learned)
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        // Fetch and Review
        async function fetchAndReview() {
            let inputWord = document.getElementById('wordInput').value.trim();
            if (!inputWord) {
                showToast('Nhập từ vựng trước!', 'error');
                return;
            }
            
            if (!currentParentId || !currentChildId) {
                showToast('Chọn category trước!', 'error');
                return;
            }
            
            document.getElementById('reviewModal').classList.add('show');
            
            let word = inputWord.toLowerCase();
            let originalVietnamese = '';
            
            // If in Vietnamese mode, translate to English first
            if (searchMode === 'vi') {
                document.getElementById('reviewContent').innerHTML = `
                    <div class="review-loading">
                        <i class="fas fa-spinner"></i>
                        <p>Đang dịch "${inputWord}" sang tiếng Anh...</p>
                    </div>
                `;
                
                try {
                    originalVietnamese = inputWord;
                    let translated = await googleTranslate(inputWord, 'vi', 'en');
                    if (translated) {
                        // Clean up: remove "to " prefix and take first word if multiple
                        translated = translated.replace(/^to\s+/i, '').trim();
                        // If result has multiple words, take the first significant word
                        const words = translated.split(/\s+/);
                        word = words[0].toLowerCase().replace(/[^a-z]/g, '');
                        
                        document.getElementById('reviewContent').innerHTML = `
                            <div class="review-loading">
                                <i class="fas fa-spinner"></i>
                                <p>"${inputWord}" → <strong>${word}</strong></p>
                                <p>Đang tìm kiếm thông tin...</p>
                            </div>
                        `;
                    } else {
                        throw new Error('Không thể dịch từ này');
                    }
                } catch (err) {
                    document.getElementById('reviewContent').innerHTML = `
                        <div class="review-loading">
                            <i class="fas fa-exclamation-triangle" style="color: var(--accent-danger); animation: none;"></i>
                            <p>Không thể dịch "${inputWord}"</p>
                        </div>
                    `;
                    return;
                }
            } else {
                document.getElementById('reviewContent').innerHTML = `
                    <div class="review-loading">
                        <i class="fas fa-spinner"></i>
                        <p>Đang tìm kiếm thông tin cho "${word}"...</p>
                    </div>
                `;
            }
            
            try {
                reviewData = [];
                
                // Try Cambridge first, then Dictionary API
                let wordData = await fetchWordDataFromCambridge(word);
                
                if (!wordData) {
                    // Fallback to Dictionary API
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                    if (!response.ok) throw new Error('Không tìm thấy từ này');
                    wordData = await response.json();
                }
                
                // Process data from either source
                if (wordData.fromCambridge) {
                    // Cambridge data format
                    for (const meaning of wordData.meanings) {
                        const meaningVi = originalVietnamese || await translateToVietnamese(word, meaning.partOfSpeech, meaning.definition, meaning.example);
                        const definitionVi = meaning.definition ? await translateSentenceToVietnamese(meaning.definition) : '';
                        const exampleVi = meaning.example ? await translateSentenceToVietnamese(meaning.example) : '';
                        reviewData.push({
                            word,
                            phonetic: wordData.phonetic || '',
                            audio: wordData.audio || '',
                            partOfSpeech: meaning.partOfSpeech,
                            definition: meaning.definition || '',
                            definitionVi,
                            example: meaning.example || '',
                            exampleVi,
                            meaningVi,
                            selected: true
                        });
                    }
                } else {
                    // Dictionary API format
                    for (const entry of wordData) {
                        const phonetic = entry.phonetic || entry.phonetics?.find(p => p.text)?.text || '';
                        const audio = entry.phonetics?.find(p => p.audio)?.audio || '';
                        
                        for (const meaning of entry.meanings) {
                            const pos = shortenPartOfSpeech(meaning.partOfSpeech);
                            
                            let bestDef = null;
                            let bestExample = '';
                            
                            for (const def of meaning.definitions) {
                                if (def.example) {
                                    bestDef = def.definition;
                                    bestExample = def.example;
                                    break;
                                }
                            }
                            
                            if (!bestDef && meaning.definitions.length > 0) {
                                bestDef = meaning.definitions[0].definition;
                                for (const def of meaning.definitions) {
                                    if (def.example) {
                                        bestExample = def.example;
                                        break;
                                    }
                                }
                            }
                            
                            const meaningVi = originalVietnamese || await translateToVietnamese(word, pos, bestDef, bestExample);
                            const definitionVi = bestDef ? await translateSentenceToVietnamese(bestDef) : '';
                            const exampleVi = bestExample ? await translateSentenceToVietnamese(bestExample) : '';
                            
                            reviewData.push({
                                word,
                                phonetic,
                                audio,
                                partOfSpeech: pos,
                                definition: bestDef || '',
                                definitionVi,
                                example: bestExample,
                                exampleVi,
                                meaningVi,
                                selected: true
                            });
                        }
                    }
                }
                
                // Remove exact duplicates (same POS and definition)
                reviewData = reviewData.filter((item, index, self) =>
                    index === self.findIndex(t => 
                        t.partOfSpeech === item.partOfSpeech && 
                        t.definition === item.definition
                    )
                );
                
                if (reviewData.length === 0) throw new Error('Không tìm thấy nghĩa nào');
                
                renderReviewList();
                
            } catch (error) {
                const viModeInfo = originalVietnamese ? `
                    <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">
                        <i class="fas fa-language"></i> "${originalVietnamese}" → <strong>${word}</strong>
                    </p>
                ` : '';
                
                document.getElementById('reviewContent').innerHTML = `
                    <div class="review-loading">
                        <i class="fas fa-exclamation-triangle" style="color: var(--accent-danger); animation: none;"></i>
                        ${viModeInfo}
                        <p>${error.message}</p>
                        <button onclick="addManualWord('${word}')" style="margin-top: 1rem; padding: 0.8rem 1.5rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-plus"></i> Thêm "${word}" thủ công
                        </button>
                    </div>
                `;
            }
        }
        
        function renderReviewList() {
            const content = document.getElementById('reviewContent');
            
            content.innerHTML = `
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <i class="fas fa-info-circle"></i> Tick chọn những nghĩa muốn thêm. Có thể sửa nghĩa tiếng Việt nếu cần:
                </p>
                <div class="review-list">
                    ${reviewData.map((item, idx) => `
                        <div class="review-item">
                            <div class="review-item-header">
                                <input type="checkbox" id="review-${idx}" ${item.selected ? 'checked' : ''} 
                                    onchange="reviewData[${idx}].selected = this.checked">
                                <span class="review-word">${item.word}</span>
                                <span class="review-pos">${item.partOfSpeech}</span>
                                <span class="review-phonetic">${item.phonetic}</span>
                                <button onclick="playWord('${item.word}', '${item.audio}')" style="background: var(--bg-secondary); border: none; color: var(--accent); padding: 0.3rem 0.5rem; border-radius: 4px; cursor: pointer; margin-left: auto;">
                                    <i class="fas fa-volume-up"></i>
                                </button>
                            </div>
                            <div class="review-info">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <strong style="color: var(--text-primary);">Nghĩa VN:</strong>
                                    <input type="text" value="${item.meaningVi || ''}" 
                                        onchange="reviewData[${idx}].meaningVi = this.value"
                                        placeholder="Nhập nghĩa tiếng Việt..."
                                        style="flex: 1; padding: 0.4rem 0.6rem; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 4px; color: var(--accent-success); font-size: 0.9rem;">
                                </div>
                                <p><strong>Definition:</strong> ${item.definition || '(không có)'}</p>
                                ${item.definitionVi ? `<p class="definition-vi">→ ${item.definitionVi}</p>` : ''}
                                ${item.example ? `
                                    <div class="review-example">"${item.example}"</div>
                                    ${item.exampleVi ? `<div class="review-example-vi">→ ${item.exampleVi}</div>` : ''}
                                ` : '<p style="color: var(--accent-warning);"><i class="fas fa-exclamation-triangle"></i> Không tìm thấy example</p>'}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        async function confirmAddSelected() {
            const selected = reviewData.filter(item => item.selected);
            
            if (selected.length === 0) {
                showToast('Chọn ít nhất một nghĩa!', 'error');
                return;
            }
            
            let added = 0;
            for (const item of selected) {
                try {
                    await database.ref(getVocabPath()).push({
                        word: item.word,
                        phonetic: item.phonetic,
                        audio: item.audio,
                        partOfSpeech: item.partOfSpeech,
                        definition: item.definition,
                        definitionVi: item.definitionVi || '',
                        example: item.example,
                        exampleVi: item.exampleVi || '',
                        meaningVi: item.meaningVi,
                        learned: false
                    });
                    added++;
                } catch (err) {
                    console.error('Error adding:', err);
                }
            }
            
            closeReviewModal();
            document.getElementById('wordInput').value = '';
            showToast(`Đã thêm ${added} từ!`, 'success');
        }
        
        function addManualWord(word) {
            database.ref(getVocabPath()).push({
                word,
                phonetic: generatePhonetic(word),
                audio: '',
                partOfSpeech: 'n',
                definition: '',
                example: '',
                meaningVi: '',
                learned: false
            }).then(() => {
                closeReviewModal();
                document.getElementById('wordInput').value = '';
                showToast('Đã thêm! Hãy chỉnh sửa thông tin.', 'info');
            }).catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        function closeReviewModal() {
            document.getElementById('reviewModal').classList.remove('show');
            reviewData = [];
        }
        
        // Translation - simple approach
        async function translateToVietnamese(word, pos, definition = '', example = '') {
            let result = '';
            
            // Translate the word with POS context
            let query = word;
            if (pos === 'v' || pos.startsWith('v')) query = `to ${word}`;
            else if (pos === 'n' || pos.startsWith('n')) query = `a ${word}`;
            
            try {
                result = await googleTranslate(query);
                if (result) {
                    result = cleanTranslation(result, pos);
                    if (result && result.toLowerCase() !== word.toLowerCase()) return result;
                }
            } catch (err) {}
            
            try {
                result = await myMemoryTranslate(query);
                if (result) {
                    result = cleanTranslation(result, pos);
                    if (result) return result;
                }
            } catch (err) {}
            
            return '';
        }
        
        function cleanTranslation(text, pos) {
            if (!text) return '';
            let cleaned = text.trim();
            
            if (pos === 'v') {
                cleaned = cleaned.replace(/^để\s+/i, '');
                cleaned = cleaned.replace(/^(một |bài |cái |sự |việc |cuộc )/i, '');
            } else if (pos === 'n') {
                cleaned = cleaned.replace(/^một\s+/i, '');
            } else if (pos === 'adj' || pos === 'adv') {
                cleaned = cleaned.replace(/^(một |bài |cái |sự )/i, '');
            }
            
            cleaned = cleaned.replace(/\s*\(.*?\)\s*/g, '').trim();
            return cleaned;
        }
        
        async function googleTranslate(text, sourceLang = 'en', targetLang = 'vi') {
            const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
            const response = await fetch(url);
            const data = await response.json();
            if (data && data[0] && data[0][0] && data[0][0][0]) return data[0][0][0].trim();
            return null;
        }
        
        async function myMemoryTranslate(text) {
            const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=en|vi`);
            const data = await response.json();
            if (data.responseStatus === 200) return data.responseData.translatedText.trim();
            return null;
        }
        
        function shortenPartOfSpeech(pos) {
            const map = {
                'noun': 'n', 'verb': 'v', 'adjective': 'adj', 'adverb': 'adv',
                'preposition': 'prep', 'conjunction': 'conj', 'interjection': 'interj', 'pronoun': 'pron'
            };
            return map[pos.toLowerCase()] || pos;
        }
        
        // Edit vocabulary
        function openEditModal(id) {
            const vocab = getCurrentVocabularies()[id];
            document.getElementById('editVocabId').value = id;
            document.getElementById('editWord').value = vocab.word || '';
            document.getElementById('editPhonetic').value = vocab.phonetic || '';
            document.getElementById('editPos').value = vocab.partOfSpeech || 'n';
            document.getElementById('editMeaningVi').value = vocab.meaningVi || '';
            document.getElementById('editDefinition').value = vocab.definition || '';
            document.getElementById('editDefinitionVi').value = vocab.definitionVi || '';
            document.getElementById('editExample').value = vocab.example || '';
            document.getElementById('editExampleVi').value = vocab.exampleVi || '';
            document.getElementById('editAudio').value = vocab.audio || '';
            document.getElementById('editModal').classList.add('show');
        }
        
        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
        }
        
        function saveEditVocab() {
            const id = document.getElementById('editVocabId').value;
            const data = {
                word: document.getElementById('editWord').value,
                phonetic: document.getElementById('editPhonetic').value,
                partOfSpeech: document.getElementById('editPos').value,
                meaningVi: document.getElementById('editMeaningVi').value,
                definition: document.getElementById('editDefinition').value,
                definitionVi: document.getElementById('editDefinitionVi').value,
                example: document.getElementById('editExample').value,
                exampleVi: document.getElementById('editExampleVi').value,
                audio: document.getElementById('editAudio').value
            };
            
            database.ref(`${getVocabPath()}/${id}`).update(data)
                .then(() => {
                    closeEditModal();
                    showToast('Đã cập nhật!', 'success');
                })
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        function deleteVocabulary(id) {
            const vocab = getCurrentVocabularies()[id];
            const msg = `Xóa từ "${vocab.word}" (${vocab.partOfSpeech})?\n\nHành động này không thể hoàn tác!`;
            
            if (!confirm(msg)) return;
            database.ref(`${getVocabPath()}/${id}`).remove()
                .then(() => showToast('Đã xóa!', 'success'))
                .catch(err => showToast('Lỗi: ' + err.message, 'error'));
        }
        
        // Audio playback
        let sharedAudio = null;
        
        function getSharedAudio() {
            if (!sharedAudio) sharedAudio = new Audio();
            return sharedAudio;
        }
        
        function playWord(word, audioUrl) {
            speakWord(word, audioUrl);
        }
        
        function speakWord(word, audioUrl, callback) {
            const audio = getSharedAudio();
            const urls = [];
            if (audioUrl && !audioUrl.startsWith('tts:')) urls.push(audioUrl);
            urls.push(
                `https://ssl.gstatic.com/dictionary/static/sounds/oxford/${word}--_us_1.mp3`,
                `https://ssl.gstatic.com/dictionary/static/sounds/oxford/${word}--_gb_1.mp3`
            );
            
            let tried = 0;
            
            function tryNext() {
                if (tried >= urls.length) {
                    speakWithTTS(word, callback);
                    return;
                }
                
                audio.src = urls[tried];
                tried++;
                
                audio.oncanplaythrough = () => audio.play().catch(() => tryNext());
                audio.onerror = () => tryNext();
                audio.onended = () => { if (callback) callback(); };
                audio.load();
            }
            
            tryNext();
        }
        
        function speakWithTTS(word, callback) {
            if (typeof responsiveVoice !== 'undefined' && responsiveVoice.voiceSupport()) {
                const timeout = setTimeout(() => { if (callback) callback(); }, 4000);
                responsiveVoice.speak(word, "US English Female", {
                    rate: 0.9,
                    onend: () => { clearTimeout(timeout); if (callback) callback(); },
                    onerror: () => { clearTimeout(timeout); speakWithNativeTTS(word, callback); }
                });
            } else {
                speakWithNativeTTS(word, callback);
            }
        }
        
        function speakWithNativeTTS(word, callback) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';
                utterance.rate = 0.85;
                
                const timeout = setTimeout(() => { if (callback) callback(); }, 3000);
                utterance.onend = () => { clearTimeout(timeout); if (callback) callback(); };
                utterance.onerror = () => { clearTimeout(timeout); if (callback) callback(); };
                speechSynthesis.speak(utterance);
            } else if (callback) {
                callback();
            }
        }
        
        // Auto Read
        function startAutoRead() {
            const mode = document.getElementById('readerMode').value;
            readingList = [];
            
            if (mode === 'all') {
                Object.values(parentCategories).forEach(parent => {
                    Object.values(parent.children || {}).forEach(child => {
                        if (child.vocabularies) {
                            Object.entries(child.vocabularies).forEach(([id, v]) => {
                                readingList.push({ id, ...v });
                            });
                        }
                    });
                });
            } else {
                const vocabs = getCurrentVocabularies();
                Object.entries(vocabs).forEach(([id, v]) => {
                    if (mode === 'unlearned' && v.learned) return;
                    readingList.push({ id, ...v });
                });
            }
            
            if (readingList.length === 0) {
                showToast('Không có từ nào để đọc!', 'error');
                return;
            }
            
            isReading = true;
            isPaused = false;
            readingIndex = 0;
            updateReaderUI();
            readCurrentWord();
        }
        
        function readCurrentWord() {
            if (!isReading || isPaused || readingIndex >= readingList.length) {
                if (readingIndex >= readingList.length) {
                    stopAutoRead();
                    showToast('Đã đọc xong!', 'success');
                }
                return;
            }
            
            const vocab = readingList[readingIndex];
            document.querySelectorAll('.vocab-item').forEach(el => el.classList.remove('reading'));
            const el = document.getElementById(`vocab-${vocab.id}`);
            if (el) {
                el.classList.add('reading');
            }
            
            // Show word with phonetic, Vietnamese meaning and part of speech
            const phonetic = vocab.phonetic || '';
            const meaningVi = vocab.meaningVi || '';
            const pos = vocab.partOfSpeech || '';
            const example = vocab.example || '';
            const readExampleEnabled = document.getElementById('readExample').checked;
            
            let displayHtml = `<strong>${vocab.word}</strong> <span style="color: var(--text-secondary);">${phonetic}</span> ` +
                `<span style="color: var(--accent-success); font-weight: 600;">${meaningVi}</span> ` +
                `<span style="background: var(--accent); color: var(--bg-primary); padding: 0.1rem 0.4rem; border-radius: 4px; font-size: 0.8rem;">${pos}</span>`;
            if (readExampleEnabled && example) {
                displayHtml += `<br><span style="color: var(--text-secondary); font-style: italic; font-size: 0.9rem; margin-top: 0.3rem; display: block;">📝 ${example}</span>`;
            }
            document.getElementById('readerCurrentWord').innerHTML = displayHtml;
            document.getElementById('readerStatus').textContent = `${readingIndex + 1} / ${readingList.length}`;
            
            speakWord(vocab.word, vocab.audio, () => {
                if (readExampleEnabled && example && !isPaused) {
                    // Read example after the word
                    setTimeout(() => {
                        if (!isPaused && isReading) {
                            speakText(example, () => {
                                const delay = parseInt(document.getElementById('readerDelay').value);
                                readingTimeout = setTimeout(() => {
                                    readingIndex++;
                                    readCurrentWord();
                                }, delay);
                            });
                        }
                    }, 500);
                } else {
                    const delay = parseInt(document.getElementById('readerDelay').value);
                    readingTimeout = setTimeout(() => {
                        readingIndex++;
                        readCurrentWord();
                    }, delay);
                }
            });
        }
        
        function speakText(text, callback) {
            if (typeof responsiveVoice !== 'undefined' && responsiveVoice.voiceSupport()) {
                responsiveVoice.speak(text, "UK English Female", {
                    rate: 0.9,
                    onend: callback
                });
            } else {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                utterance.onend = callback;
                utterance.onerror = callback;
                speechSynthesis.speak(utterance);
            }
        }
        
        function saveReaderSettings() {
            localStorage.setItem('readerReadExample', document.getElementById('readExample').checked);
        }
        
        function loadReaderSettings() {
            const readExample = localStorage.getItem('readerReadExample');
            if (readExample !== null) {
                document.getElementById('readExample').checked = readExample === 'true';
            }
        }
        
        function pauseAutoRead() {
            isPaused = true;
            clearTimeout(readingTimeout);
            if (typeof responsiveVoice !== 'undefined') responsiveVoice.cancel();
            speechSynthesis.cancel();
            updateReaderUI();
        }
        
        function resumeAutoRead() {
            isPaused = false;
            updateReaderUI();
            readCurrentWord();
        }
        
        function stopAutoRead() {
            isReading = false;
            isPaused = false;
            readingIndex = 0;
            clearTimeout(readingTimeout);
            if (typeof responsiveVoice !== 'undefined') responsiveVoice.cancel();
            speechSynthesis.cancel();
            
            document.querySelectorAll('.vocab-item').forEach(el => el.classList.remove('reading'));
            document.getElementById('readerCurrentWord').textContent = '';
            document.getElementById('readerStatus').textContent = 'Sẵn sàng';
            updateReaderUI();
        }
        
        function updateReaderUI() {
            const playBtn = document.querySelector('.reader-btn.play');
            const pauseBtn = document.querySelector('.reader-btn.pause');
            
            if (isReading && !isPaused) {
                playBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-flex';
                pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                pauseBtn.onclick = pauseAutoRead;
            } else if (isReading && isPaused) {
                playBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-flex';
                pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
                pauseBtn.onclick = resumeAutoRead;
            } else {
                playBtn.style.display = 'inline-flex';
                pauseBtn.style.display = 'none';
            }
        }
        
        // Sync functions
        async function syncVocabAudio(id, btn) {
            const vocab = getCurrentVocabularies()[id];
            btn.classList.add('spinning');
            
            try {
                const audio = await fetchAudioFromSources(vocab.word);
                if (audio) {
                    await database.ref(`${getVocabPath()}/${id}/audio`).set(audio);
                    showToast('Đã cập nhật audio!', 'success');
                } else {
                    showToast('Không tìm thấy audio', 'error');
                }
            } catch (err) {
                showToast('Lỗi: ' + err.message, 'error');
            }
            
            btn.classList.remove('spinning');
        }
        
        async function syncVocabPhonetic(id, btn) {
            const vocab = getCurrentVocabularies()[id];
            btn.classList.add('spinning');
            
            try {
                let phonetic = await fetchPhoneticFromSources(vocab.word);
                if (!phonetic) phonetic = generatePhonetic(vocab.word);
                
                await database.ref(`${getVocabPath()}/${id}/phonetic`).set(phonetic);
                showToast('Đã cập nhật phonetic!', 'success');
            } catch (err) {
                showToast('Lỗi: ' + err.message, 'error');
            }
            
            btn.classList.remove('spinning');
        }
        
        async function syncVocabExample(id, btn) {
            const vocab = getCurrentVocabularies()[id];
            btn.classList.add('spinning');
            
            try {
                let example = await fetchExampleFromSources(vocab.word, vocab.partOfSpeech);
                if (example) {
                    // Translate example to Vietnamese
                    const exampleVi = await translateSentenceToVietnamese(example);
                    
                    await database.ref(`${getVocabPath()}/${id}`).update({
                        example: example,
                        exampleVi: exampleVi || ''
                    });
                    showToast('Đã cập nhật example!', 'success');
                } else {
                    showToast('Không tìm thấy example phù hợp', 'warning');
                }
            } catch (err) {
                showToast('Lỗi sync example', 'error');
            }
            
            btn.classList.remove('spinning');
        }
        
        async function translateSentenceToVietnamese(sentence) {
            if (!sentence) return '';
            
            try {
                const res = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(sentence)}`);
                if (res.ok) {
                    const data = await res.json();
                    return data[0]?.map(x => x[0]).join('') || '';
                }
            } catch (e) {}
            
            return '';
        }
        
        async function fetchExampleFromSources(word, partOfSpeech) {
            // Source 1: Cambridge Dictionary (highest quality)
            try {
                const example = await fetchFromCambridge(word, partOfSpeech);
                if (example) return example;
            } catch (e) {}
            
            // Source 2: Dictionary API
            try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (res.ok) {
                    const data = await res.json();
                    const targetPos = expandPartOfSpeech(partOfSpeech);
                    
                    // First try to find example matching the POS
                    for (const entry of data) {
                        for (const meaning of (entry.meanings || [])) {
                            if (targetPos && meaning.partOfSpeech !== targetPos) continue;
                            for (const def of (meaning.definitions || [])) {
                                if (def.example) {
                                    return def.example;
                                }
                            }
                        }
                    }
                    
                    // Fallback: any example if POS not matched
                    for (const entry of data) {
                        for (const meaning of (entry.meanings || [])) {
                            for (const def of (meaning.definitions || [])) {
                                if (def.example) {
                                    return def.example;
                                }
                            }
                        }
                    }
                }
            } catch (e) {}
            
            // Source 3: Tatoeba (sentence database)
            try {
                const res = await fetch(`https://tatoeba.org/en/api_v0/search?from=eng&query=${encodeURIComponent(word)}&limit=5`);
                if (res.ok) {
                    const data = await res.json();
                    if (data.results && data.results.length > 0) {
                        const sentences = data.results
                            .filter(r => r.text && r.text.length < 150)
                            .map(r => r.text);
                        if (sentences.length > 0) {
                            return sentences[0];
                        }
                    }
                }
            } catch (e) {}
            
            // Source 4: Use Google Translate round-trip
            try {
                const example = await generateExampleWithAI(word);
                if (example) return example;
            } catch (e) {}
            
            return null;
        }
        
        function expandPartOfSpeech(shortPos) {
            const map = {
                'n': 'noun', 'v': 'verb', 'adj': 'adjective', 'adv': 'adverb',
                'prep': 'preposition', 'conj': 'conjunction', 'pron': 'pronoun',
                'interj': 'interjection', 'det': 'determiner', 'num': 'numeral'
            };
            return map[(shortPos || '').toLowerCase()] || shortPos;
        }
        
        async function fetchFromCambridge(word, partOfSpeech) {
            const proxyUrls = [
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`,
                `https://corsproxy.io/?${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`
            ];
            
            const targetPos = expandPartOfSpeech(partOfSpeech);
            
            for (const proxyUrl of proxyUrls) {
                try {
                    const res = await fetch(proxyUrl, { 
                        headers: { 'Accept': 'text/html' },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (res.ok) {
                        const html = await res.text();
                        
                        // Split by POS blocks and find matching POS
                        const posBlocks = html.split(/(?=<div class="pr entry-body__el)/i);
                        
                        let fallbackExample = null;
                        
                        for (const block of posBlocks) {
                            if (!block.includes('entry-body__el')) continue;
                            
                            // Get POS from this block
                            const posMatch = block.match(/<span class="pos dpos"[^>]*>([^<]+)<\/span>/i);
                            const blockPos = posMatch ? posMatch[1].trim().toLowerCase() : '';
                            
                            // Find examples in this block
                            const exMatch = block.match(/<span class="eg deg"[^>]*>([\s\S]*?)<\/span>/i);
                            if (exMatch) {
                                const example = exMatch[1].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
                                if (example && example.length > 10 && example.length < 200) {
                                    // If POS matches, return immediately
                                    if (targetPos && blockPos === targetPos) {
                                        return example;
                                    }
                                    // Otherwise save as fallback
                                    if (!fallbackExample) {
                                        fallbackExample = example;
                                    }
                                }
                            }
                        }
                        
                        // Return fallback if no exact POS match
                        if (fallbackExample) return fallbackExample;
                    }
                } catch (e) {}
            }
            
            return null;
        }
        
        async function fetchWordDataFromCambridge(word) {
            const proxyUrls = [
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`,
                `https://corsproxy.io/?${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`
            ];
            
            for (const proxyUrl of proxyUrls) {
                try {
                    const res = await fetch(proxyUrl, { 
                        headers: { 'Accept': 'text/html' },
                        signal: AbortSignal.timeout(8000)
                    });
                    
                    if (res.ok) {
                        const html = await res.text();
                        
                        // Check if word exists
                        if (html.includes('page-not-found') || !html.includes('entry-body')) {
                            continue;
                        }
                        
                        // Extract phonetic (IPA)
                        let phonetic = '';
                        const ipaMatch = html.match(/<span class="ipa[^"]*"[^>]*>([^<]+)<\/span>/i);
                        if (ipaMatch && ipaMatch[1]) {
                            phonetic = '/' + ipaMatch[1].trim() + '/';
                        }
                        
                        // Extract audio URL
                        let audio = '';
                        const audioMatch = html.match(/data-src-mp3="([^"]+)"/i);
                        if (audioMatch && audioMatch[1]) {
                            audio = audioMatch[1];
                            if (!audio.startsWith('http')) {
                                audio = 'https://dictionary.cambridge.org' + audio;
                            }
                        }
                        
                        // Extract meanings (part of speech, definition, example)
                        const meanings = [];
                        
                        // Split HTML by POS entry blocks (each starts with "pr entry-body__el")
                        // Cambridge structure: each POS has its own entry-body__el block
                        const posBlocks = html.split(/(?=<div class="pr entry-body__el)/i);
                        
                        for (const block of posBlocks) {
                            if (!block.includes('entry-body__el')) continue;
                            
                            // Get part of speech from this block
                            const posMatch = block.match(/<span class="pos dpos"[^>]*>([^<]+)<\/span>/i);
                            if (!posMatch) continue;
                            const pos = shortenPartOfSpeech(posMatch[1].trim());
                            
                            // Split by sense blocks (different meanings within same POS)
                            // Cambridge uses "pr dsense" for each sense/meaning
                            const senseBlocks = block.split(/(?=<div class="pr dsense)/i);
                            
                            let meaningIndex = 0;
                            for (const senseBlock of senseBlocks) {
                                // Get sense title if available (e.g., "MOVE FORWARD", "DEVELOP")
                                let senseTitle = '';
                                const senseTitleMatch = senseBlock.match(/<span class="dsense_h"[^>]*>([^<]+)<\/span>/i) ||
                                                       senseBlock.match(/<h3 class="dsense_h"[^>]*>([\s\S]*?)<\/h3>/i);
                                if (senseTitleMatch) {
                                    senseTitle = senseTitleMatch[1].replace(/<[^>]+>/g, '').trim();
                                }
                                
                                // Find def-blocks within this sense block
                                const defBlocks = senseBlock.split(/(?=<div class="def-block)/i);
                                
                                for (const defBlock of defBlocks) {
                                    if (!defBlock.includes('def-block')) continue;
                                    
                                    // Get definition from this def-block
                                    const defMatch = defBlock.match(/<div class="def ddef_d db"[^>]*>([\s\S]*?)<\/div>/i);
                                    if (!defMatch) continue;
                                    
                                    let definition = defMatch[1]
                                        .replace(/<[^>]+>/g, '')
                                        .replace(/\s+/g, ' ')
                                        .trim()
                                        .replace(/:$/, '');
                                    
                                    if (!definition) continue;
                                    
                                    // Get example from the SAME def-block (important!)
                                    const exMatch = defBlock.match(/<span class="eg deg"[^>]*>([\s\S]*?)<\/span>/i);
                                    let example = '';
                                    if (exMatch) {
                                        example = exMatch[1]
                                            .replace(/<[^>]+>/g, '')
                                            .replace(/\s+/g, ' ')
                                            .trim();
                                    }
                                    
                                    // Create unique POS label for multiple meanings
                                    meaningIndex++;
                                    let posLabel = pos;
                                    if (senseTitle) {
                                        posLabel = `${pos} (${senseTitle})`;
                                    } else if (meaningIndex > 1) {
                                        posLabel = `${pos} (${meaningIndex})`;
                                    }
                                    
                                    // Check if this definition is already added (avoid duplicates)
                                    const isDuplicate = meanings.some(m => 
                                        m.definition.toLowerCase() === definition.toLowerCase()
                                    );
                                    
                                    if (!isDuplicate) {
                                        meanings.push({ 
                                            partOfSpeech: posLabel, 
                                            definition, 
                                            example 
                                        });
                                    }
                                    
                                    // Limit to max 3 definitions per POS for faster processing
                                    if (meanings.filter(m => m.partOfSpeech.startsWith(pos)).length >= 3) {
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Fallback: if no meanings found, try simpler parsing
                        if (meanings.length === 0) {
                            const posMatch = html.match(/<span class="pos dpos"[^>]*>([^<]+)<\/span>/i);
                            const pos = posMatch ? shortenPartOfSpeech(posMatch[1].trim()) : 'n';
                            
                            const defMatch = html.match(/<div class="def ddef_d db"[^>]*>([\s\S]*?)<\/div>/i);
                            let definition = defMatch ? defMatch[1].replace(/<[^>]+>/g, '').trim().replace(/:$/, '') : '';
                            
                            // Find example near the definition
                            const exMatch = html.match(/<span class="eg deg"[^>]*>([\s\S]*?)<\/span>/i);
                            let example = exMatch ? exMatch[1].replace(/<[^>]+>/g, '').trim() : '';
                            
                            if (definition) {
                                meanings.push({ partOfSpeech: pos, definition, example });
                            }
                        }
                        
                        if (meanings.length > 0) {
                            return {
                                fromCambridge: true,
                                phonetic,
                                audio,
                                meanings
                            };
                        }
                    }
                } catch (e) {}
            }
            
            return null;
        }
        
        async function generateExampleWithAI(word) {
            // Use Google Translate's suggestion feature indirectly
            // by translating a template and back
            try {
                const templates = [
                    `I use ${word} in my daily life.`,
                    `The ${word} is important for everyone.`,
                    `We should ${word} more often.`,
                    `Learning about ${word} is useful.`
                ];
                
                // Pick a template and verify it makes sense via translation round-trip
                const template = templates[Math.floor(Math.random() * templates.length)];
                
                // Translate to Vietnamese
                const viRes = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(template)}`);
                if (viRes.ok) {
                    const viData = await viRes.json();
                    const viText = viData[0]?.map(x => x[0]).join('') || '';
                    
                    // Translate back to English to get a natural sentence
                    const enRes = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=vi&tl=en&dt=t&q=${encodeURIComponent(viText)}`);
                    if (enRes.ok) {
                        const enData = await enRes.json();
                        const enText = enData[0]?.map(x => x[0]).join('') || '';
                        if (enText && enText.toLowerCase().includes(word.toLowerCase())) {
                            return enText;
                        }
                    }
                }
            } catch (e) {}
            
            return null;
        }
        
        async function fetchAudioFromSources(word) {
            // Source 1: Cambridge Dictionary (highest quality)
            try {
                const audio = await fetchAudioFromCambridge(word);
                if (audio) return audio;
            } catch (e) {}
            
            // Source 2: Dictionary API
            try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (res.ok) {
                    const data = await res.json();
                    const audio = data[0]?.phonetics?.find(p => p.audio)?.audio;
                    if (audio) return audio;
                }
            } catch (e) {}
            
            return null;
        }
        
        async function fetchAudioFromCambridge(word) {
            const proxyUrls = [
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`,
                `https://corsproxy.io/?${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`
            ];
            
            for (const proxyUrl of proxyUrls) {
                try {
                    const res = await fetch(proxyUrl, { 
                        headers: { 'Accept': 'text/html' },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (res.ok) {
                        const html = await res.text();
                        
                        // Cambridge audio URLs are in data-src-mp3 attributes
                        const audioMatch = html.match(/data-src-mp3="([^"]+)"/i);
                        if (audioMatch && audioMatch[1]) {
                            let audioUrl = audioMatch[1];
                            if (!audioUrl.startsWith('http')) {
                                audioUrl = 'https://dictionary.cambridge.org' + audioUrl;
                            }
                            return audioUrl;
                        }
                    }
                } catch (e) {}
            }
            
            return null;
        }
        
        async function fetchPhoneticFromSources(word) {
            // Source 1: Cambridge Dictionary (highest quality IPA)
            try {
                const phonetic = await fetchPhoneticFromCambridge(word);
                if (phonetic) return phonetic;
            } catch (e) {}
            
            // Source 2: Dictionary API
            try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (res.ok) {
                    const data = await res.json();
                    const phonetic = data[0]?.phonetic || data[0]?.phonetics?.find(p => p.text)?.text;
                    if (phonetic) return phonetic;
                }
            } catch (e) {}
            
            // Source 3: Datamuse API
            try {
                const res = await fetch(`https://api.datamuse.com/words?sp=${word}&md=r&max=1`);
                if (res.ok) {
                    const data = await res.json();
                    if (data[0]?.tags) {
                        const ipaTag = data[0].tags.find(t => t.startsWith('ipa_pron:'));
                        if (ipaTag) return '/' + ipaTag.replace('ipa_pron:', '') + '/';
                    }
                }
            } catch (e) {}
            
            return null;
        }
        
        async function fetchPhoneticFromCambridge(word) {
            const proxyUrls = [
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`,
                `https://corsproxy.io/?${encodeURIComponent(`https://dictionary.cambridge.org/dictionary/english/${word}`)}`
            ];
            
            for (const proxyUrl of proxyUrls) {
                try {
                    const res = await fetch(proxyUrl, { 
                        headers: { 'Accept': 'text/html' },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (res.ok) {
                        const html = await res.text();
                        
                        // Cambridge phonetic is in <span class="ipa dipa lpr-2 lpl-1">
                        // or <span class="pron dpron">/<span class="ipa">...</span>/</span>
                        const ipaMatch = html.match(/<span class="ipa[^"]*"[^>]*>([^<]+)<\/span>/i);
                        if (ipaMatch && ipaMatch[1]) {
                            const ipa = ipaMatch[1].trim();
                            if (ipa && !ipa.startsWith('/')) {
                                return '/' + ipa + '/';
                            }
                            return ipa;
                        }
                    }
                } catch (e) {}
            }
            
            return null;
        }
        
        function generatePhonetic(word) {
            const rules = [
                [/ph/gi, 'f'], [/tion/gi, 'ʃən'], [/sion/gi, 'ʒən'],
                [/ck/gi, 'k'], [/ch/gi, 'tʃ'], [/sh/gi, 'ʃ'],
                [/th/gi, 'θ'], [/ng/gi, 'ŋ'], [/qu/gi, 'kw'],
                [/ee/gi, 'iː'], [/ea/gi, 'iː'], [/oo/gi, 'uː'],
                [/ou/gi, 'aʊ'], [/ow/gi, 'aʊ'], [/oi/gi, 'ɔɪ'],
                [/oy/gi, 'ɔɪ'], [/ai/gi, 'eɪ'], [/ay/gi, 'eɪ'],
                [/y$/gi, 'i'], [/e$/gi, '']
            ];
            
            let result = word.toLowerCase();
            rules.forEach(([pattern, replacement]) => {
                result = result.replace(pattern, replacement);
            });
            
            return `/${result}/`;
        }
        
        // Speech recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;
                
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('wordInput').value = transcript;
                    stopVoiceInput();
                };
                
                recognition.onerror = () => stopVoiceInput();
                recognition.onend = () => stopVoiceInput();
            }
        }
        
        function toggleVoiceInput() {
            if (isRecording) stopVoiceInput();
            else startVoiceInput();
        }
        
        function startVoiceInput() {
            if (!recognition) {
                showToast('Trình duyệt không hỗ trợ voice input', 'error');
                return;
            }
            isRecording = true;
            document.getElementById('voiceBtn').classList.add('recording');
            recognition.start();
        }
        
        function stopVoiceInput() {
            isRecording = false;
            document.getElementById('voiceBtn').classList.remove('recording');
            if (recognition) recognition.stop();
        }
        
        // Mobile sidebar
        function toggleMobileSidebar() {
            document.querySelector('.sidebar').classList.toggle('show');
            document.querySelector('.sidebar-overlay').classList.toggle('show');
        }
        
        function closeMobileSidebar() {
            document.querySelector('.sidebar').classList.remove('show');
            document.querySelector('.sidebar-overlay').classList.remove('show');
        }
        
        // Search mode toggle (EN→VI or VI→EN)
        function toggleSearchMode() {
            searchMode = searchMode === 'en' ? 'vi' : 'en';
            const btn = document.getElementById('searchModeBtn');
            const input = document.getElementById('wordInput');
            
            if (searchMode === 'vi') {
                btn.innerHTML = '<i class="fas fa-exchange-alt"></i> VI→EN';
                btn.classList.add('vi-mode');
                input.placeholder = 'Nhập từ tiếng Việt...';
                showToast('Chế độ: Tìm từ tiếng Anh từ tiếng Việt', 'info');
            } else {
                btn.innerHTML = '<i class="fas fa-exchange-alt"></i> EN→VI';
                btn.classList.remove('vi-mode');
                input.placeholder = 'Nhập từ tiếng Anh...';
                showToast('Chế độ: Tìm từ tiếng Anh', 'info');
            }
        }
        
        // Practice mode toggle
        let practiceMode = localStorage.getItem('practiceMode') === 'true';
        
        function initPracticeMode() {
            if (practiceMode) {
                document.body.classList.add('practice-mode');
                document.getElementById('practiceToggle').classList.add('active');
                updatePracticeButton(true);
            }
        }
        
        function togglePracticeMode() {
            practiceMode = !practiceMode;
            localStorage.setItem('practiceMode', practiceMode);
            
            if (practiceMode) {
                document.body.classList.add('practice-mode');
                document.getElementById('practiceToggle').classList.add('active');
                showToast('Đã bật chế độ ôn tập - Hover để xem nghĩa', 'info');
            } else {
                document.body.classList.remove('practice-mode');
                document.getElementById('practiceToggle').classList.remove('active');
                showToast('Đã tắt chế độ ôn tập', 'info');
            }
            
            updatePracticeButton(practiceMode);
        }
        
        function updatePracticeButton(isActive) {
            const btn = document.getElementById('practiceToggle');
            if (isActive) {
                btn.innerHTML = '<i class="fas fa-eye"></i> Hiện nghĩa';
            } else {
                btn.innerHTML = '<i class="fas fa-eye-slash"></i> Ẩn nghĩa';
            }
        }
        
        // Toast
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        // Enter key
        document.getElementById('wordInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') fetchAndReview();
        });
        
        document.getElementById('newParentName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addParentCategory();
        });
        
    </script>
</body>
</html>
